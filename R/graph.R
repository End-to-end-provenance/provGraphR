#' Create provenance graph
#' 
#' create.graph creates an adjacency graph containing the procedure and
#' data nodes in saved provenance.
#'
#' @param prov.input This is either a file name or a string contain provenance
#'   in PROV-JSON format.  PROV-JSON can be generated by RDataTracker
#'   or provR.  If this parameter is
#'   missing, and prov.parse has been called previously, that parsed provenance
#'   will be used.
#' @param isFile A logical that determines whether or not the prov.input parameter
#'   contains a file name or contains the provenance in a string.  This parameter is
#'   ignored if prov.input is missing.
#' 
#' @return create.graph returns a matrix representation of the graph.  There is a row and a column for each
#'   data and procedure node in the graph.  The values in the matrix are either 1 or 0.
#'   A 1 indicates that there is an edge for the column node to the row node.  create.graph returns
#'   NULL if there is no provenance available.
#'
#' @export
#' @examples 
#' create.graph(system.file("testdata", "prov.json", package = "provGraphR"))
create.graph <- function(prov.input = NULL, isFile = T){

  if (!is.null (prov.input)) {
    provParseR::prov.parse (prov.input, isFile)
  }
  
  proc.nodes <- provParseR::get.proc.nodes()
  if (is.null (proc.nodes)) {
    warning ("There is no provenance to create a graph from.")
    return (NULL)
  }

  # Collects all the ids of all the nodes that are put into the graph
  # Type is a vector of characters
  ids <- c(provParseR::get.proc.nodes()$'id', provParseR::get.data.nodes()$'id')

  # Collects the connections between nodes that exist in the prov
  # Originally there will be 3 columns including the ids, so
  # subset out the two columns that are required for the graph
  # Type is a matrix so that the graph can be subset by it
  proc.data.edges <- provParseR::get.proc.data()[c("entity", "activity")]
  data.proc.edges <- provParseR::get.data.proc()[c("activity", "entity")]
  edges <- as.matrix(rbind(proc.data.edges,
                           stats::setNames(rev(data.proc.edges), names(data.proc.edges))))
                  
  # Create the graph, populating each element with zeros by the length of nodes
  adj.graph <- Matrix::Matrix(0, nrow = length(ids), ncol = length(ids), sparse =T)

  # Make sure the resulting matrix is labelled for grabbing the right node
  rownames(adj.graph) <- colnames(adj.graph) <- ids

  # Sets all connections to 1 by subsetting by the edges matrix
  apply(edges, 1, function(edge){
    adj.graph[edge[1], edge[2]] <<- 1
  })

  return (adj.graph)
}

#' Calculate lineage of a node
#' 
#' get.lineage returns the lineage of the provided node.  Forward lineage identifies
#' everything that depends on the provided node.  Backward lineage identifies
#' everything the provided node depends on.
#' 
#' Most commonly, the node passed in is a data node representing either a variable,
#' a file, or a plot.  Forward lineage reports everything computed from that variable
#' or file.  Backward lineage reports everything that contributed to the variable's 
#' value, the contents of an output file or plot.
#' 
#' @param adj.graph An adjacency graph to get the lineage from.  The
#'   graph can be created by a call to create.graph.
#' 
#' @param node.id This is a string id for a node that the lineage is
#'   being requested for
#'
#' @param forward Logical that states whether the search is going forward
#'   through the graph from the provided node, or backwards.
#' 
#' @return get.lineage returns the forward or backward lineage of the specified node.  The lineage
#'   is represented as a vector of character, with each being a different node label.
#' 
#' @export
#' @examples 
#' adj.graph <- create.graph(system.file("testdata", "prov.json", package = "provGraphR"))
#' get.lineage (adj.graph, "d33")
#' 
#' @seealso \code{\link{create.graph}}
get.lineage <- function(adj.graph, node.id, forward = F){
  if(!forward){
    ig <- igraph::graph_from_adjacency_matrix(adj.graph)
  } else {
    ig <- igraph::graph_from_adjacency_matrix(Matrix::t(adj.graph))
  }

  as.character(stats::na.omit(names(igraph::dfs(ig, node.id, "out" , unreachable = FALSE)$order)))
}

